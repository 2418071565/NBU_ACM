## **本质**

整数二分（英语：Binary Search on Integers），对整数区间进行二分查找，可以找出用某个性质（check函数）划分出的区间的两个边界点。

比如：在$[1，2，3，3，4]$这个数组中，用「大于等于3」这条性质划分出的区间为（后为下标，从1开始）：$[1，2]$和$[3，5]$。可以利用二分来确定下标为「2」的边界点（对应原数组中的2）和下标为「3」的边界点（对应原数组中左数第一个3）。

## **左侧的边界点**

想要查找到左侧的边界点「2」（小于3的最大值），可以用下面这个二分模板。

```c++
ll l = 1, r = n;
while(l < r) {
    ll mid = (l + r + 1) >> 1; // 这里写ll是防止整数溢出
    if(a[mid] >= 3) r = mid - 1; // 因为左侧区域必定是小于3的，当前的mid不可能是右侧区域的边界
    else l = mid; // 小于3的mid可能是答案
}

return l; // return r也可以，while循环结束l = r
```

## **右侧的边界点**

想要查找到右侧的边界点「3」（大于等于3的最小值），可以用下面这个二分模板。

```c++
ll l = 1, r = n;
while(l < r) {
    ll mid = (l + r) >> 1;
    if(a[mid] >= 3) r = mid; // 右侧区域必定大于等于3，当前的mid可能是右侧区域的边界
    else l = mid + 1;  // 小于3的mid不可能是答案
}

return l; // return r也可以，理由同上
```

代码中值得注意的点有两个：

第一个是l、r的去向，究竟是取$mid$还是$mid + 1$？

其实，l和r决定的区间[l、r]叫做查找区间，在这个区间内部的任何一个都满足被查找边界的条件。因此，只需要看当前这个mid是否满足左侧边界的条件（这里是$< 3$），或者是否满足右侧边界的条件（这里是$\geq 3$）就能确定。如果当前的mid满足被查找边界的条件，那么就取，不能满足，那就取$mid + 1$

第二个是$mid$的取值，究竟内部的$l + r$要不要再加1？

有个简单粗暴的记法，只看$l$，如果$l = mid + 1$这里加了1，那么$mid$取值就不需要加，如果$l$没有加，那么$mid$的取值就加1。

实际上也可以简单模拟一下，在$l = mid$时，如果出现了$l = r - 1$的情况，那么如果$mid$的取值不加1，会发现$l$恒等于$r - 1$（>> 1的向下取整），导致死循环。另外一种情况同理。

一些十分简易的二分情况也可以使用C++STL中的lower_bound与upper_bound函数来实现。