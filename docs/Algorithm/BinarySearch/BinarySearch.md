## **整数二分**

### **本质**

整数二分，对一个有序区间进行二分查找，可以找出用某个性质（check函数）划分出的区间的两个边界点。

> 注意：这里的有序并不单指具有单调性，只要能利用某种性质把区间划分为两个子区间就算有序

比如：在$[1，2，3，3，4]$这个数组中（见下图），用「**大于等于3**」这条性质划分出的区间为（后为下标，从1开始）：$[1 \sim 2]$和$[3 \sim 5]$。可以利用二分来确定下标为「2」的边界点（对应原数组中的2）和下标为「3」的边界点（对应原数组中左数第一个3）。

![BinarySearch](.\\Img\BinarySearch.png "区间划分")

### **查找左侧区间的边界点**

想要查找到左侧的边界点「2」（小于3的最大值），可以用下面这个二分模板。

```c++
ll l = 1, r = n;
while(l < r) {
    ll mid = (l + r + 1) >> 1; // 这里写ll是防止整数溢出
    if(a[mid] >= 3) r = mid - 1; // 因为左侧区域必定是小于3的，当前的mid不可能是右侧区域的边界
    else l = mid; // 小于3的mid可能是答案
}

return l; // return r也可以，while循环结束l = r
```

### **查找右侧区间的边界点**

想要查找到右侧的边界点「3」（大于等于3的最小值），可以用下面这个二分模板。

```c++
ll l = 1, r = n;
while(l < r) {
    ll mid = (l + r) >> 1;
    if(a[mid] >= 3) r = mid; // 右侧区域必定大于等于3，当前的mid可能是右侧区域的边界
    else l = mid + 1;  // 小于3的mid不可能是答案
}

return l; // return r也可以，理由同上
```

代码中值得注意的点有两个：

第一个是$l、r$的去向，究竟是取$mid$还是$mid + 1$？

其实，$l$和$r$决定的区间$[l、r]$叫做查找区间，在这个区间内部的任何一个都满足被查找边界的条件。因此，只需要看当前这个mid是否满足左侧边界的条件（这里是$< 3$），或者是否满足右侧边界的条件（这里是$\geq 3$）就能确定。如果当前的mid满足被查找边界的条件，那么就取，不能满足，那就取$mid + 1$

第二个是$mid$的取值，究竟内部的$l + r$要不要再加1？

有个简单粗暴的记法，只看$l$，如果$l = mid + 1$这里加了1，那么$mid$取值就不需要加，如果$l$没有加，那么$mid$的取值就加1。

实际上也可以简单模拟一下，在$l = mid$时，如果出现了$l = r - 1$的情况，那么如果$mid$的取值不加1，会发现$l$恒等于$r - 1$（>> 1的向下取整），导致死循环。另外一种情况同理。

一些十分简易的二分情况也可以使用C++STL中的lower_bound与upper_bound函数来实现。

### **整数二分的应用场景**

#### **数据查找**

如上文的例子，查找第一个3出现的位置或最后一个3出现的位置等。在数据量大且询问次数多时，可以利用二分将$O(n*m)$的时间复杂度优化为$O(m*\
log n)$

推荐完成[洛谷 P2249 【深基13.例1】查找](https://www.luogu.com.cn/problem/P2249)

#### **二分答案**

对于部分问题，有时难以通过题目的描述正向得出答案，但是可以确定答案所在的区间，且可以很轻易地判断某个答案是否符合要求，就可以使用「枚举答案」的方法来解题。

如果恰好答案所在的区间满足某种有序性，即可以根据「是否满足题目要求」这个性质划分为两个连续的子区间，就可以通过二分的方法来优化枚举答案带来的时间开销。

> 这一类型的题目往往有一些类似于寻找「最大值中的最小值」、「最小值中的最大值」等的描述

推荐完成[洛谷 P2240 木材加工](https://www.luogu.com.cn/problem/P2440)

## **浮点数二分**

### **特点**

浮点数二分比整数二分稍微简单一些。利用浮点数二分可以找到一个满足「精度要求」的边界点。

利用浮点数二分解决问题的思想是跟二分答案一样的，根据数据的范围确定答案的区间$[l, r]$，再通过不断缩小查找区间（精度）来寻找满足精度要求的答案。

c++代码实现如下

```cpp
double binarySearch(double l, double r) {
	const double eps = 1e-5;
	while(r - l > eps) {
		double mid = (l + r) / 2;
		if(check(mid)) l = mid;
		else r = mid;
	}

	return l;
}
```

推荐完成[洛谷 P1024 [NOIP2001 提高组] 一元三次方程求解](https://www.luogu.com.cn/problem/P1024)